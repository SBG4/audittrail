---
phase: 02-audit-schemas-cases
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/models/audit_type.py
  - server/src/models/__init__.py
  - server/src/schemas/audit_type.py
  - server/src/routers/audit_types.py
  - server/src/main.py
  - server/alembic/versions/002_create_audit_types_table.py
  - server/src/scripts/seed.py
autonomous: true

must_haves:
  truths:
    - "GET /audit-types returns a list of audit types including USB usage and email usage"
    - "Each audit type response includes a JSON Schema definition describing its metadata fields"
    - "USB usage schema contains serial_number, user_name, user_id, computer_used properties"
    - "Email usage schema contains email_address, email_server, account_owner, department properties"
  artifacts:
    - path: "server/src/models/audit_type.py"
      provides: "AuditType SQLAlchemy model with JSONB schema column"
      contains: "class AuditType"
    - path: "server/src/schemas/audit_type.py"
      provides: "Pydantic schemas for AuditType API"
      contains: "class AuditTypeRead"
    - path: "server/src/routers/audit_types.py"
      provides: "CRUD endpoints for audit types"
      exports: ["router"]
    - path: "server/alembic/versions/002_create_audit_types_table.py"
      provides: "Migration creating audit_types table"
      contains: "create_table"
    - path: "server/src/scripts/seed.py"
      provides: "Seeds USB usage and email usage audit types"
      contains: "USB"
  key_links:
    - from: "server/src/routers/audit_types.py"
      to: "server/src/models/audit_type.py"
      via: "SQLAlchemy queries"
      pattern: "select.*AuditType"
    - from: "server/src/main.py"
      to: "server/src/routers/audit_types.py"
      via: "include_router"
      pattern: "include_router.*audit_type"
---

<objective>
Create the audit type schema registry: AuditType model with JSONB schema column, Alembic migration, CRUD API endpoints, and seed data for USB usage and email usage audit types.

Purpose: Establishes the foundation for schema-driven case management. All subsequent plans depend on audit types existing in the database.
Output: AuditType model, migration, API endpoints, seed data with two audit types.
</objective>

<execution_context>
@/Users/shiro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shiro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-audit-schemas-cases/02-RESEARCH.md
@.planning/phases/01-infrastructure-auth/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: AuditType model, Pydantic schemas, and Alembic migration</name>
  <files>
    server/src/models/audit_type.py
    server/src/models/__init__.py
    server/src/schemas/audit_type.py
    server/alembic/versions/002_create_audit_types_table.py
  </files>
  <action>
    Create the AuditType SQLAlchemy model in `server/src/models/audit_type.py`:
    - Fields: id (UUID, primary key, default uuid4), name (String(100), unique, not null), slug (String(100), unique, not null, indexed), description (Text, nullable), schema (JSONB, not null -- this stores the JSON Schema definition), is_active (Boolean, default True), created_at (DateTime with timezone, server_default=func.now()), updated_at (DateTime with timezone, server_default=func.now(), onupdate=func.now())
    - Import JSONB from `sqlalchemy.dialects.postgresql`
    - Import func from `sqlalchemy`
    - IMPORTANT: The JSONB column stores JSON Schema (Draft 2020-12 compatible) defining the metadata fields for this audit type

    Update `server/src/models/__init__.py` to import AuditType alongside User.

    Create Pydantic schemas in `server/src/schemas/audit_type.py`:
    - `AuditTypeRead(BaseModel)`: id (UUID), name (str), slug (str), description (str | None), schema_ (dict, alias="schema"), is_active (bool), created_at (datetime). Use `model_config = ConfigDict(from_attributes=True, populate_by_name=True)`.
    - `AuditTypeCreate(BaseModel)`: name (str), slug (str), description (str | None = None), schema_ (dict, alias="schema"). Add field validator for schema_ to ensure it's a valid JSON Schema object type.
    - `AuditTypeList(BaseModel)`: items (list[AuditTypeRead]), total (int)
    - Note: Use `schema_` as the Python field name with `alias="schema"` since `schema` conflicts with Pydantic BaseModel's internal attribute. Use `serialization_alias="schema"` so the JSON output key is "schema".

    Create Alembic migration `server/alembic/versions/002_create_audit_types_table.py`:
    - revision: "002", down_revision: "001"
    - Create table "audit_types" with all columns matching the model
    - Create unique index on slug
    - The schema column is sa.dialects.postgresql.JSONB
    - Add created_at with server_default=sa.func.now(), updated_at with server_default=sa.func.now()
  </action>
  <verify>
    - `cd server && python -c "from src.models.audit_type import AuditType; print(AuditType.__tablename__)"` outputs "audit_types"
    - `cd server && python -c "from src.schemas.audit_type import AuditTypeRead, AuditTypeCreate; print('OK')"` outputs "OK"
    - Migration file exists at server/alembic/versions/002_create_audit_types_table.py
  </verify>
  <done>AuditType model with JSONB schema column, Pydantic schemas with proper alias handling, and Alembic migration all exist and import correctly.</done>
</task>

<task type="auto">
  <name>Task 2: AuditType CRUD router, seed data, and registration</name>
  <files>
    server/src/routers/audit_types.py
    server/src/main.py
    server/src/scripts/seed.py
  </files>
  <action>
    Create `server/src/routers/audit_types.py` with APIRouter(prefix="/audit-types", tags=["audit-types"]):

    - GET "/" -> list all active audit types. Return AuditTypeList with items and total count. No auth required (or use get_current_user for protected access -- follow the auth pattern from routers/auth.py). Query: `select(AuditType).where(AuditType.is_active == True).order_by(AuditType.name)`. Protected with get_current_user.
    - GET "/{audit_type_id}" -> get single audit type by UUID. Return AuditTypeRead. Raise 404 if not found. Protected with get_current_user.

    Note: POST/PUT/DELETE for audit types are NOT needed for v1 (only 2 fixed types seeded). Keep the router simple -- read-only endpoints.

    Register the router in `server/src/main.py`: import and include `audit_types_router` with `app.include_router(audit_types_router)`.

    Update `server/src/scripts/seed.py` to seed audit types alongside the admin user:
    - Add USB Usage audit type with slug "usb-usage", name "USB Usage", description "Audit of USB device usage and data transfers", and JSON Schema:
      ```json
      {
        "type": "object",
        "properties": {
          "serial_number": {"type": "string", "title": "S/N"},
          "user_name": {"type": "string", "title": "User Name"},
          "user_id": {"type": "string", "title": "User ID"},
          "computer_used": {"type": "string", "title": "Computer Used"}
        },
        "required": ["serial_number", "user_name", "user_id", "computer_used"]
      }
      ```
    - Add Email Usage audit type with slug "email-usage", name "Email Usage", description "Audit of email account usage and communications", and JSON Schema:
      ```json
      {
        "type": "object",
        "properties": {
          "email_address": {"type": "string", "title": "Email Address"},
          "email_server": {"type": "string", "title": "Email Server"},
          "account_owner": {"type": "string", "title": "Account Owner"},
          "department": {"type": "string", "title": "Department"}
        },
        "required": ["email_address", "account_owner"]
      }
      ```
    - Use upsert-style seeding (check if slug exists before inserting) to be idempotent, matching the existing seed pattern for the admin user.
  </action>
  <verify>
    - `cd server && python -c "from src.routers.audit_types import router; print([r.path for r in router.routes])"` shows the two routes
    - `cd server && python -c "from src.main import app; paths = [r.path for r in app.routes]; assert '/audit-types/' in paths or '/audit-types' in paths; print('Router registered')"` confirms registration
    - `cd server && python -c "from src.scripts.seed import *; print('Seed imports OK')"` confirms seed script is valid
  </verify>
  <done>GET /audit-types and GET /audit-types/{id} endpoints return audit type data including JSON Schema. Seed script creates USB usage and email usage types with proper schemas.</done>
</task>

</tasks>

<verification>
- AuditType model imports and has correct table name and JSONB schema column
- Pydantic schemas handle the "schema" field alias correctly
- Migration 002 depends on migration 001 and creates audit_types table
- Router has GET list and GET detail endpoints
- Router is registered in main.py
- Seed script creates both USB usage and email usage audit types with correct JSON Schemas
- All existing Phase 1 functionality (auth endpoints, health check) still works
</verification>

<success_criteria>
1. `GET /audit-types` returns both USB usage and email usage audit types with their JSON Schema definitions
2. `GET /audit-types/{id}` returns a single audit type with its schema
3. Audit type schemas contain the correct properties and required fields per the requirements (CASE-01, CASE-02)
4. Migration chain is valid: 001 -> 002
5. Seed script is idempotent (can run multiple times without error)
</success_criteria>

<output>
After completion, create `.planning/phases/02-audit-schemas-cases/02-01-SUMMARY.md`
</output>
