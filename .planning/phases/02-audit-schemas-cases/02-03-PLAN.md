---
phase: 02-audit-schemas-cases
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - client/package.json
  - client/pnpm-lock.yaml
  - client/src/main.tsx
  - client/src/types/case.ts
  - client/src/hooks/useAuditTypes.ts
  - client/src/hooks/useCases.ts
  - client/src/components/cases/SchemaForm.tsx
  - client/src/pages/CaseCreatePage.tsx
  - client/src/App.tsx
  - client/src/components/ui/select.tsx
  - client/src/components/ui/textarea.tsx
autonomous: true

must_haves:
  truths:
    - "User can navigate to a case creation page"
    - "User can select an audit type (USB usage or email usage) and the form displays type-specific metadata fields"
    - "USB usage form shows S/N, User Name, User ID, Computer Used fields"
    - "Email usage form shows Email Address, Email Server, Account Owner, Department fields"
    - "User can fill in the form and submit to create a new case"
    - "Validation errors from the server are displayed to the user"
  artifacts:
    - path: "client/src/components/cases/SchemaForm.tsx"
      provides: "Dynamic form renderer from JSON Schema"
      contains: "SchemaForm"
    - path: "client/src/pages/CaseCreatePage.tsx"
      provides: "Case creation page with audit type selection and schema form"
      contains: "CaseCreatePage"
    - path: "client/src/hooks/useCases.ts"
      provides: "TanStack Query hooks for case API operations"
      contains: "useCreateCase"
    - path: "client/src/hooks/useAuditTypes.ts"
      provides: "TanStack Query hook for fetching audit types"
      contains: "useAuditTypes"
    - path: "client/src/types/case.ts"
      provides: "TypeScript types for cases and audit types"
      contains: "Case"
  key_links:
    - from: "client/src/pages/CaseCreatePage.tsx"
      to: "client/src/components/cases/SchemaForm.tsx"
      via: "React component composition"
      pattern: "<SchemaForm"
    - from: "client/src/hooks/useCases.ts"
      to: "/api/cases"
      via: "API fetch calls"
      pattern: "api\\.post.*cases"
    - from: "client/src/App.tsx"
      to: "client/src/pages/CaseCreatePage.tsx"
      via: "React Router route"
      pattern: "CaseCreatePage"
---

<objective>
Create the schema-driven case creation UI: TanStack Query setup, TypeScript types, audit type fetching, dynamic schema form component, and case creation page with audit type selection and auto-populated metadata fields.

Purpose: Enables auditors to create new cases by selecting an audit type and filling in type-specific metadata fields that are dynamically rendered from the JSON Schema.
Output: Case creation page with dynamic form, TanStack Query hooks, TypeScript types.
</objective>

<execution_context>
@/Users/shiro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shiro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-audit-schemas-cases/02-RESEARCH.md
@.planning/phases/02-audit-schemas-cases/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: TanStack Query setup, TypeScript types, and API hooks</name>
  <files>
    client/package.json
    client/pnpm-lock.yaml
    client/src/main.tsx
    client/src/types/case.ts
    client/src/hooks/useAuditTypes.ts
    client/src/hooks/useCases.ts
  </files>
  <action>
    Install TanStack Query:
    ```bash
    cd client && pnpm add @tanstack/react-query
    ```

    Wrap the app with QueryClientProvider in `client/src/main.tsx`:
    - Import QueryClient, QueryClientProvider from @tanstack/react-query
    - Create a QueryClient instance with default options: queries.staleTime = 5 * 60 * 1000 (5 min), queries.retry = 1
    - Wrap the existing `<App />` with `<QueryClientProvider client={queryClient}>`

    Create `client/src/types/case.ts` with TypeScript interfaces:
    - `AuditType`: id (string), name (string), slug (string), description (string | null), schema (JsonSchema), is_active (boolean), created_at (string)
    - `JsonSchema`: type (string), properties (Record<string, JsonSchemaProperty>), required (string[])
    - `JsonSchemaProperty`: type (string), title (string), format? (string), enum? (string[])
    - `Case`: id (string), case_number (number), title (string), description (string | null), audit_type_id (string), audit_type (AuditType | null), metadata (Record<string, unknown>), status ("open" | "active" | "closed"), assigned_to_id (string | null), assigned_to (UserInfo | null), created_by_id (string), created_by (UserInfo | null), created_at (string), updated_at (string)
    - `UserInfo`: id (string), username (string), full_name (string), is_active (boolean)
    - `CaseListResponse`: items (Case[]), total (number), offset (number), limit (number)
    - `CreateCaseRequest`: title (string), audit_type_id (string), description? (string), metadata (Record<string, unknown>)
    - `UpdateCaseRequest`: title? (string), description? (string), metadata? (Record<string, unknown>), status? (string), assigned_to_id? (string | null)
    - `CaseFilters`: status? (string), audit_type_id? (string), assigned_to_id? (string), search? (string), offset? (number), limit? (number)

    Create `client/src/hooks/useAuditTypes.ts`:
    - `useAuditTypes()` hook using useQuery: queryKey ["audit-types"], queryFn fetches GET /api/audit-types, returns AuditType list from response.items
    - `useAuditType(id: string)` hook using useQuery: queryKey ["audit-types", id], queryFn fetches GET /api/audit-types/{id}, returns single AuditType. Enabled only when id is truthy.

    Create `client/src/hooks/useCases.ts`:
    - `useCases(filters: CaseFilters)` hook using useQuery: queryKey ["cases", filters], queryFn builds query string from non-empty filter values and fetches GET /api/cases?{params}, returns CaseListResponse
    - `useCase(id: string)` hook using useQuery: queryKey ["cases", id], queryFn fetches GET /api/cases/{id}, returns Case
    - `useCreateCase()` hook using useMutation: mutationFn POST /api/cases with CreateCaseRequest body, onSuccess invalidates ["cases"] queries
    - `useUpdateCase()` hook using useMutation: mutationFn PATCH /api/cases/{id} with UpdateCaseRequest body, onSuccess invalidates ["cases"] and ["cases", id]
    - `useDeleteCase()` hook using useMutation: mutationFn DELETE /api/cases/{id}, onSuccess invalidates ["cases"]

    All hooks use the existing `api` helper from `@/lib/api`.
    Add a `patch` method to the api helper in `client/src/lib/api.ts` if it doesn't exist (for PATCH requests, same pattern as put but with method: "PATCH").
  </action>
  <verify>
    - `cd client && npx tsc --noEmit` passes (TypeScript compilation)
    - `cd client && pnpm build` succeeds
  </verify>
  <done>TanStack Query is configured, TypeScript types cover all case/audit-type shapes, and API hooks provide useAuditTypes, useCases, useCreateCase, useUpdateCase, useDeleteCase.</done>
</task>

<task type="auto">
  <name>Task 2: SchemaForm component and CaseCreatePage</name>
  <files>
    client/src/components/cases/SchemaForm.tsx
    client/src/pages/CaseCreatePage.tsx
    client/src/App.tsx
    client/src/components/ui/select.tsx
    client/src/components/ui/textarea.tsx
  </files>
  <action>
    Add shadcn components needed:
    ```bash
    cd client && npx shadcn@latest add select textarea
    ```

    Create `client/src/components/cases/SchemaForm.tsx`:
    - Props: schema (JsonSchema), values (Record<string, unknown>), onChange (callback receiving updated values), disabled? (boolean)
    - Renders form fields dynamically from schema.properties:
      - For each property key in schema.properties, render a labeled field
      - Use the property's `title` for the label, falling back to the key name
      - Field types:
        - "string" -> shadcn Input component
        - "number" / "integer" -> shadcn Input with type="number"
        - "string" with format "email" -> shadcn Input with type="email"
        - "string" with enum -> shadcn Select component
      - Mark fields as required if they appear in schema.required array (show * next to label)
      - onChange handler: when any field changes, call onChange with the full updated values object `{ ...values, [key]: newValue }`
    - Use a grid layout: 2 columns on larger screens (grid-cols-1 md:grid-cols-2 gap-4)
    - Each field wrapped in a div with Label component above the input

    Create `client/src/pages/CaseCreatePage.tsx`:
    - Page title: "Create New Case"
    - Form with sections:
      1. **Case Details**: title (Input, required), description (Textarea, optional)
      2. **Audit Type Selection**: Select dropdown populated from useAuditTypes() hook. When audit type changes, reset metadata to empty object and update the SchemaForm.
      3. **Metadata Fields**: Rendered by SchemaForm component, passing the selected audit type's schema. Show a placeholder message ("Select an audit type to see metadata fields") when no type is selected.
    - Form state: Use React useState for title, description, selected audit_type_id, and metadata object
    - Submit: Use useCreateCase() mutation. On submit, validate title is non-empty and audit type is selected (client-side). Call mutation with {title, description, audit_type_id, metadata}. On success, navigate to the case list page using react-router's useNavigate.
    - Error handling: Display server validation errors (from mutation.error) in an error alert below the form. Display field-level required indicators.
    - Loading state: Disable submit button and show loading text while mutation is pending
    - Cancel button: navigates back to case list

    Update `client/src/App.tsx`:
    - Add route `/cases/new` -> CaseCreatePage inside the AuthGuard + Layout wrapper
    - Import CaseCreatePage
  </action>
  <verify>
    - `cd client && pnpm build` succeeds
    - `cd client && npx tsc --noEmit` passes
    - CaseCreatePage.tsx exists and contains SchemaForm reference
    - App.tsx contains route for /cases/new
  </verify>
  <done>SchemaForm dynamically renders form fields from JSON Schema. CaseCreatePage provides audit type selection, auto-populated metadata form, and case creation with validation. Route is registered at /cases/new.</done>
</task>

</tasks>

<verification>
- TanStack Query is installed and QueryClientProvider wraps the app
- TypeScript types match the API response shapes from Plan 02-02
- All hooks use the existing api helper and follow consistent patterns
- SchemaForm correctly renders fields for both USB usage and email usage schemas
- CaseCreatePage handles the full creation flow: type selection -> form fill -> submit -> redirect
- New route /cases/new is protected by AuthGuard
- Client builds without TypeScript errors
</verification>

<success_criteria>
1. User can navigate to /cases/new and see the case creation form (CASE-01)
2. Selecting USB usage shows S/N, User Name, User ID, Computer Used fields (CASE-02)
3. Selecting Email usage shows Email Address, Email Server, Account Owner, Department fields (CASE-02)
4. Submitting the form creates a case via the API and redirects to the case list
5. Server-side validation errors are displayed to the user
6. Client builds and TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-audit-schemas-cases/02-03-SUMMARY.md`
</output>
