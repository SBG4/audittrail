---
phase: 02-audit-schemas-cases
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - server/src/models/case.py
  - server/src/models/__init__.py
  - server/src/schemas/case.py
  - server/src/routers/cases.py
  - server/src/main.py
  - server/alembic/versions/003_create_cases_table.py
  - server/pyproject.toml
  - server/uv.lock
autonomous: true

must_haves:
  truths:
    - "User can create a case by providing a title, audit_type_id, and metadata -- metadata is validated against the audit type's JSON Schema"
    - "User can list cases with optional filtering by status, audit_type_id, assigned_to_id, and text search"
    - "User can update case metadata, title, description, status, and assignment"
    - "User can delete a case"
    - "Status transitions are enforced: open->active, open->closed, active->closed, closed->open"
    - "Invalid metadata against the audit type schema returns 422 with a descriptive error"
  artifacts:
    - path: "server/src/models/case.py"
      provides: "Case SQLAlchemy model with JSONB metadata, status, assignment"
      contains: "class Case"
    - path: "server/src/schemas/case.py"
      provides: "Pydantic schemas for Case CRUD"
      contains: "CaseCreate"
    - path: "server/src/routers/cases.py"
      provides: "Full CRUD + filtering endpoints for cases"
      exports: ["router"]
    - path: "server/alembic/versions/003_create_cases_table.py"
      provides: "Migration creating cases table with foreign keys"
      contains: "create_table"
  key_links:
    - from: "server/src/routers/cases.py"
      to: "server/src/models/case.py"
      via: "SQLAlchemy queries with selectinload"
      pattern: "select.*Case"
    - from: "server/src/routers/cases.py"
      to: "server/src/models/audit_type.py"
      via: "Schema lookup for validation"
      pattern: "AuditType"
    - from: "server/src/main.py"
      to: "server/src/routers/cases.py"
      via: "include_router"
      pattern: "include_router.*cases"
---

<objective>
Create the Cases API with full CRUD, lifecycle state management, user assignment, metadata validation against audit type schemas, and case list filtering/search.

Purpose: Enables the core case management workflow -- creating, editing, assigning, filtering, and deleting audit cases with schema-validated metadata.
Output: Case model, migration, full CRUD API with filtering, metadata validation, lifecycle enforcement.
</objective>

<execution_context>
@/Users/shiro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shiro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-audit-schemas-cases/02-RESEARCH.md
@.planning/phases/02-audit-schemas-cases/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Case model, Pydantic schemas, and migration</name>
  <files>
    server/src/models/case.py
    server/src/models/__init__.py
    server/src/schemas/case.py
    server/alembic/versions/003_create_cases_table.py
    server/pyproject.toml
    server/uv.lock
  </files>
  <action>
    First, add the `jsonschema` dependency:
    ```bash
    cd server && uv add jsonschema
    ```

    Create `server/src/models/case.py` with the Case SQLAlchemy model:
    - Fields: id (UUID pk, default uuid4), case_number (Integer, unique, autoincrement, not null -- human-readable identifier), title (String(200), not null), description (Text, nullable), audit_type_id (UUID, ForeignKey("audit_types.id", ondelete="RESTRICT"), not null), metadata_ mapped to column name "metadata" (JSONB, not null, default=dict), status (String(20), not null, default="open", indexed), assigned_to_id (UUID, ForeignKey("users.id", ondelete="SET NULL"), nullable), created_by_id (UUID, ForeignKey("users.id", ondelete="RESTRICT"), not null), created_at (DateTime(timezone=True), server_default=func.now()), updated_at (DateTime(timezone=True), server_default=func.now(), onupdate=func.now())
    - Relationships: audit_type = relationship("AuditType", lazy="selectin"), assigned_to = relationship("User", foreign_keys=[assigned_to_id], lazy="selectin"), created_by = relationship("User", foreign_keys=[created_by_id], lazy="selectin")
    - CRITICAL: Use `metadata_: Mapped[dict] = mapped_column("metadata", JSONB, ...)` to avoid SQLAlchemy MetaData naming conflict
    - Import JSONB from sqlalchemy.dialects.postgresql
    - Add GIN index: `Index('ix_cases_metadata', metadata_, postgresql_using='gin')` in __table_args__

    Update `server/src/models/__init__.py` to import Case.

    Create `server/src/schemas/case.py` with Pydantic schemas:
    - `CaseCreate(BaseModel)`: title (str, max 200 chars), description (str | None = None), audit_type_id (UUID), metadata (dict = {})
    - `CaseUpdate(BaseModel)`: title (str | None = None), description (str | None = None), metadata (dict | None = None), status (str | None = None), assigned_to_id (UUID | None = None). All fields optional for partial update.
    - `CaseRead(BaseModel)`: id (UUID), case_number (int), title (str), description (str | None), audit_type_id (UUID), audit_type (AuditTypeRead | None = None), metadata (dict), status (str), assigned_to_id (UUID | None), assigned_to (UserRead | None = None), created_by_id (UUID), created_by (UserRead | None = None), created_at (datetime), updated_at (datetime). Use `model_config = ConfigDict(from_attributes=True)`. Use a field alias or property to map `metadata_` -> `metadata` in serialization.
    - `CaseListResponse(BaseModel)`: items (list[CaseRead]), total (int), offset (int), limit (int)
    - Import AuditTypeRead from schemas.audit_type and UserRead from schemas.user

    Create migration `server/alembic/versions/003_create_cases_table.py`:
    - revision: "003", down_revision: "002"
    - Create table "cases" with all columns
    - case_number: sa.Integer, autoincrement=True, unique=True, nullable=False (use sa.Identity() for auto-increment or sa.Sequence)
    - metadata column: sa.dialects.postgresql.JSONB, nullable=False, server_default=sa.text("'{}'::jsonb")
    - Foreign keys: audit_type_id -> audit_types.id (ondelete RESTRICT), assigned_to_id -> users.id (ondelete SET NULL), created_by_id -> users.id (ondelete RESTRICT)
    - Indexes: ix_cases_status on status, ix_cases_metadata GIN index on metadata, ix_cases_audit_type_id on audit_type_id
  </action>
  <verify>
    - `cd server && python -c "from src.models.case import Case; print(Case.__tablename__)"` outputs "cases"
    - `cd server && python -c "from src.schemas.case import CaseCreate, CaseRead, CaseUpdate, CaseListResponse; print('OK')"` outputs "OK"
    - `cd server && python -c "import jsonschema; print(jsonschema.__version__)"` confirms jsonschema is installed
    - Migration file 003 exists and references down_revision "002"
  </verify>
  <done>Case model with JSONB metadata, relationships, GIN index, Pydantic CRUD schemas, and migration exist and import correctly. jsonschema library installed.</done>
</task>

<task type="auto">
  <name>Task 2: Cases CRUD router with validation, lifecycle, and filtering</name>
  <files>
    server/src/routers/cases.py
    server/src/main.py
  </files>
  <action>
    Create `server/src/routers/cases.py` with APIRouter(prefix="/cases", tags=["cases"]):

    **Helper functions (module-level):**

    1. `validate_case_metadata(metadata: dict, schema: dict) -> None`: Uses `jsonschema.validate()` to check metadata against the audit type's JSON Schema. Catches `jsonschema.ValidationError` and raises HTTPException 422 with the validation message.

    2. `VALID_TRANSITIONS` dict: {"open": ["active", "closed"], "active": ["closed"], "closed": ["open"]}

    3. `validate_status_transition(current: str, target: str) -> None`: Checks if target is in VALID_TRANSITIONS[current]. Raises HTTPException 400 if invalid.

    **Endpoints (all protected with `current_user: User = Depends(get_current_user)`):**

    1. `POST "/"` -> Create case
       - Accept CaseCreate body
       - Fetch the AuditType by audit_type_id, raise 404 if not found
       - Validate metadata against audit_type.schema using validate_case_metadata
       - Create Case with status="open", created_by_id=current_user.id
       - Commit, refresh (with selectinload for audit_type, assigned_to, created_by), return CaseRead
       - Status code 201

    2. `GET "/"` -> List cases with filtering
       - Query params: status (str | None), audit_type_id (UUID | None), assigned_to_id (UUID | None), search (str | None), offset (int = 0), limit (int = 20, le=100)
       - Build query with selectinload for audit_type, assigned_to, created_by
       - Apply filters conditionally: status exact match, audit_type_id exact match, assigned_to_id exact match
       - Search: if search provided, filter where title ILIKE %search% OR description ILIKE %search%
       - Count total matching records (before pagination)
       - Order by updated_at DESC, apply offset/limit
       - Return CaseListResponse

    3. `GET "/{case_id}"` -> Get single case
       - Fetch by UUID with selectinload for all relationships
       - Raise 404 if not found
       - Return CaseRead

    4. `PATCH "/{case_id}"` -> Update case (partial)
       - Accept CaseUpdate body
       - Fetch case, raise 404 if not found
       - If status is being changed, validate transition using validate_status_transition
       - If metadata is being changed, fetch the audit type and validate against schema
       - Apply only provided (non-None) fields using `model_dump(exclude_unset=True)`
       - For metadata, REPLACE the entire dict (not merge) to avoid mutation tracking issues
       - Commit, refresh, return CaseRead

    5. `DELETE "/{case_id}"` -> Delete case
       - Fetch case, raise 404 if not found
       - Delete and commit
       - Return 204 No Content

    6. `GET "/{case_id}/assign"` is not needed -- assignment is done via PATCH with assigned_to_id.

    Register the router in `server/src/main.py`: import and include `cases_router`.
  </action>
  <verify>
    - `cd server && python -c "from src.routers.cases import router; print([r.path for r in router.routes])"` shows all 5 routes
    - `cd server && python -c "from src.main import app; paths = [r.path for r in app.routes]; print([p for p in paths if 'cases' in p])"` confirms registration
    - `cd server && python -c "from src.routers.cases import validate_case_metadata, VALID_TRANSITIONS; print('Helpers OK')"` confirms helper functions exist
  </verify>
  <done>Full CRUD for cases: create with schema validation, list with filtering/search/pagination, get detail, partial update with lifecycle enforcement, and delete. All endpoints protected with JWT auth.</done>
</task>

</tasks>

<verification>
- Case model has JSONB metadata column with GIN index
- Relationships use selectin lazy loading (no async lazy load issues)
- CaseCreate validates metadata against audit type JSON Schema
- CaseUpdate enforces lifecycle transitions (open->active->closed, closed->open)
- List endpoint supports filtering by status, audit_type_id, assigned_to_id, and text search
- Delete returns 204
- All endpoints require JWT authentication
- Migration chain: 001 -> 002 -> 003
- jsonschema library is installed in server dependencies
</verification>

<success_criteria>
1. POST /cases creates a case with validated metadata (CASE-01, CASE-02)
2. PATCH /cases/{id} updates case fields including metadata with re-validation (CASE-03)
3. DELETE /cases/{id} removes a case (CASE-04)
4. PATCH /cases/{id} with status change enforces valid transitions (CASE-05)
5. GET /cases with filters returns paginated, filtered case list (CASE-06)
6. PATCH /cases/{id} with assigned_to_id assigns a case to an auditor (CASE-07)
7. Invalid metadata returns 422 with descriptive validation error
</success_criteria>

<output>
After completion, create `.planning/phases/02-audit-schemas-cases/02-02-SUMMARY.md`
</output>
