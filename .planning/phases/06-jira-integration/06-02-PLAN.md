---
phase: 06-jira-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/models/jira_field_mapping.py
  - server/src/models/__init__.py
  - server/alembic/versions/005_create_jira_field_mappings_table.py
  - server/src/routers/jira.py
  - server/src/scripts/seed.py
autonomous: true

must_haves:
  truths:
    - "JiraFieldMapping model stores per-audit-type mappings from Jira fields to case metadata keys"
    - "CRUD endpoints exist for managing field mappings"
    - "Default mappings are seeded for USB Usage and Email Usage audit types"
  artifacts:
    - path: "server/src/models/jira_field_mapping.py"
      provides: "JiraFieldMapping SQLAlchemy model"
    - path: "server/alembic/versions/005_create_jira_field_mappings_table.py"
      provides: "Alembic migration for jira_field_mappings table"
  key_links:
    - from: "server/src/routers/jira.py"
      to: "server/src/models/jira_field_mapping.py"
      via: "SQLAlchemy queries in mapping CRUD endpoints"
      pattern: "JiraFieldMapping"
    - from: "server/src/models/jira_field_mapping.py"
      to: "server/src/models/audit_type.py"
      via: "ForeignKey to audit_types.id"
      pattern: "ForeignKey.*audit_types"
---

<objective>
Create the JiraFieldMapping database model, migration, and CRUD endpoints for managing per-audit-type field mappings between Jira fields and case metadata keys.

Purpose: Provides JIRA-03 -- configurable field mapping per audit type. Also seeds sensible defaults.
Output: JiraFieldMapping model, migration, CRUD endpoints, and seed data.
</objective>

<execution_context>
@/Users/shiro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shiro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@server/src/models/audit_type.py
@server/src/models/case.py
@server/src/schemas/jira.py
@server/src/scripts/seed.py
@server/alembic/versions/004_create_events_table.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: JiraFieldMapping model and migration</name>
  <files>
    server/src/models/jira_field_mapping.py
    server/src/models/__init__.py
    server/alembic/versions/005_create_jira_field_mappings_table.py
  </files>
  <action>
  1. Create `server/src/models/jira_field_mapping.py`:
     ```python
     class JiraFieldMapping(Base):
         __tablename__ = "jira_field_mappings"
         __table_args__ = (
             UniqueConstraint("audit_type_id", "jira_field_name", name="uq_jira_mapping_type_field"),
         )

         id: Mapped[uuid.UUID] = mapped_column(primary_key=True, default=uuid.uuid4)
         audit_type_id: Mapped[uuid.UUID] = mapped_column(
             ForeignKey("audit_types.id", ondelete="CASCADE"), nullable=False, index=True
         )
         jira_field_name: Mapped[str] = mapped_column(String(200), nullable=False)
         case_metadata_key: Mapped[str] = mapped_column(String(200), nullable=False)
         created_at: Mapped[datetime] = mapped_column(
             DateTime(timezone=True), server_default=func.now()
         )

         # Relationship
         audit_type = relationship("AuditType", lazy="selectin")
     ```

  2. Update `server/src/models/__init__.py` to import `JiraFieldMapping` so Alembic sees it.

  3. Create manual migration `server/alembic/versions/005_create_jira_field_mappings_table.py`:
     - Follow the pattern of existing migrations (004)
     - Revision id: generate a short unique id
     - `down_revision` = revision id from 004
     - `upgrade()`:
       - Create table `jira_field_mappings` with columns: id (UUID PK), audit_type_id (UUID FK to audit_types.id ON DELETE CASCADE), jira_field_name (VARCHAR(200) NOT NULL), case_metadata_key (VARCHAR(200) NOT NULL), created_at (TIMESTAMP WITH TIME ZONE DEFAULT now())
       - Add unique constraint on (audit_type_id, jira_field_name)
       - Add index on audit_type_id
     - `downgrade()`: Drop table `jira_field_mappings`
  </action>
  <verify>
  - `python -c "from src.models.jira_field_mapping import JiraFieldMapping; print('OK')"` from server dir
  - Migration file exists and has correct down_revision
  </verify>
  <done>JiraFieldMapping model exists with FK to audit_types, unique constraint on (audit_type_id, jira_field_name), and corresponding Alembic migration.</done>
</task>

<task type="auto">
  <name>Task 2: Field mapping CRUD endpoints and seed data</name>
  <files>
    server/src/routers/jira.py
    server/src/scripts/seed.py
  </files>
  <action>
  1. Add to `server/src/routers/jira.py` (append to existing router from 06-01):
     - `GET /mappings/{audit_type_id}` endpoint:
       - Requires authentication
       - Queries JiraFieldMapping where audit_type_id matches
       - Returns `list[JiraFieldMappingRead]`

     - `PUT /mappings/{audit_type_id}` endpoint:
       - Requires authentication
       - Accepts `JiraFieldMappingBulkUpdate` body (list of mappings)
       - Deletes all existing mappings for this audit_type_id
       - Inserts all new mappings from body
       - Returns `list[JiraFieldMappingRead]`
       - This is a "replace all" approach -- simpler than individual CRUD for mapping config

     - `POST /scrape-and-map` endpoint:
       - Requires authentication
       - Accepts `JiraScrapeRequest` body + `audit_type_id: uuid.UUID` query param
       - Calls JiraScraper.scrape_issue() to get raw fields
       - Loads mappings for the audit_type_id
       - Applies mapping: for each scraped field, if a mapping exists, include in result with the case_metadata_key
       - Returns `JiraScrapeResponse` with `fields` = mapped fields only, `raw_fields` = all scraped fields

  2. Update `server/src/scripts/seed.py` to seed default field mappings:
     - After seeding audit types, seed JiraFieldMapping entries:
     - USB Usage defaults:
       - "Assignee" -> "user_name"
       - "Summary" -> "serial_number"
       - "Reporter" -> "user_id"
     - Email Usage defaults:
       - "Assignee" -> "account_owner"
       - "Summary" -> "email_address"
       - "Reporter" -> "account_owner"
     - Use idempotent seed pattern: check if mappings exist for audit type before inserting
  </action>
  <verify>
  - `python -c "from src.routers.jira import router; print([r.path for r in router.routes])"` shows /scrape, /mappings/{audit_type_id}, /scrape-and-map
  - `grep "JiraFieldMapping" server/src/scripts/seed.py` confirms seed data
  </verify>
  <done>GET/PUT /api/jira/mappings/{audit_type_id} endpoints for managing field mappings. POST /api/jira/scrape-and-map combines scraping with mapping application. Default mappings seeded for both audit types.</done>
</task>

</tasks>

<verification>
- JiraFieldMapping model imports cleanly
- Migration file has correct revision chain
- All three new endpoints (GET mappings, PUT mappings, POST scrape-and-map) are registered
- Seed script includes default mappings
</verification>

<success_criteria>
- Per-audit-type field mappings stored in database with unique constraint
- Bulk update (replace all) approach for mapping management
- scrape-and-map endpoint combines scraping and mapping in one call
- Default mappings seeded for USB Usage and Email Usage
</success_criteria>

<output>
After completion, create `.planning/phases/06-jira-integration/06-02-SUMMARY.md`
</output>
