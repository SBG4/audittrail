---
phase: 03-timeline-events
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/models/event.py
  - server/src/models/__init__.py
  - server/src/schemas/event.py
  - server/src/routers/events.py
  - server/src/main.py
  - server/alembic/versions/004_create_events_table.py
autonomous: true

must_haves:
  truths:
    - "Events CRUD API returns correct responses for create, read, update, delete"
    - "Events are scoped to a case (case_id in URL path)"
    - "Events list returns items sorted chronologically by event_date and event_time"
    - "Event metadata is stored as JSONB and validated"
  artifacts:
    - path: "server/src/models/event.py"
      provides: "Event SQLAlchemy model with JSONB metadata"
      contains: "class Event"
    - path: "server/src/schemas/event.py"
      provides: "Pydantic schemas for event CRUD"
      exports: ["EventCreate", "EventUpdate", "EventRead"]
    - path: "server/src/routers/events.py"
      provides: "FastAPI router with CRUD endpoints"
      contains: "router = APIRouter"
    - path: "server/alembic/versions/004_create_events_table.py"
      provides: "Database migration for events table"
      contains: "create_table"
  key_links:
    - from: "server/src/routers/events.py"
      to: "server/src/models/event.py"
      via: "SQLAlchemy queries"
    - from: "server/src/main.py"
      to: "server/src/routers/events.py"
      via: "app.include_router"
---

<objective>
Create the Events API with full CRUD operations, scoped under cases. Each event captures date, time, file name, file count, file description, file type, event type, and JSONB metadata.

Purpose: Backend foundation for the timeline feature (EVNT-01, EVNT-04, EVNT-05)
Output: Event model, migration, Pydantic schemas, REST endpoints
</objective>

<execution_context>
@/Users/shiro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shiro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@server/src/models/case.py
@server/src/schemas/case.py
@server/src/routers/cases.py
@server/src/main.py
@server/src/deps.py
@server/src/database.py
@server/alembic/versions/003_create_cases_table.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Event model, migration, and schemas</name>
  <files>
    server/src/models/event.py
    server/src/models/__init__.py
    server/src/schemas/event.py
    server/alembic/versions/004_create_events_table.py
  </files>
  <action>
    Create Event SQLAlchemy model in server/src/models/event.py following the exact same patterns as case.py:
    - id: UUID primary key with uuid4 default
    - case_id: UUID FK to cases.id with ondelete CASCADE
    - event_type: String(20) not null, default "note". Valid values: "finding", "action", "note"
    - event_date: Date not null (the date the event occurred)
    - event_time: Time nullable (optional time component)
    - file_name: String(500) nullable
    - file_count: Integer nullable
    - file_description: Text nullable
    - file_type: String(100) nullable
    - metadata_: JSONB column mapped as "metadata", not null, default dict (same pattern as Case)
    - sort_order: Integer not null default 0 (for ordering within same date/time)
    - created_by_id: UUID FK to users.id with ondelete RESTRICT
    - created_at: DateTime(timezone=True) server_default=func.now()
    - updated_at: DateTime(timezone=True) server_default=func.now() onupdate=func.now()
    - Relationship: case = relationship("Case", lazy="selectin")
    - Relationship: created_by = relationship("User", lazy="selectin")
    - Index on case_id for fast filtering
    - Index on event_date for chronological ordering

    Add Event to server/src/models/__init__.py imports and __all__.

    Create Pydantic schemas in server/src/schemas/event.py:
    - EventCreate: event_type (str, default "note"), event_date (date), event_time (time | None), file_name (str | None), file_count (int | None), file_description (str | None), file_type (str | None), metadata (dict, default_factory=dict)
    - EventUpdate: All fields optional (same pattern as CaseUpdate). event_type, event_date, event_time, file_name, file_count, file_description, file_type, metadata all optional.
    - EventRead: All fields including id, case_id, event_type, event_date, event_time, file_name, file_count, file_description, file_type, metadata (with validation_alias="metadata_"), sort_order, created_by_id, created_by (UserRead | None), created_at, updated_at. ConfigDict(from_attributes=True, populate_by_name=True).
    - EventListResponse: items (list[EventRead]), total (int)

    Create migration 004_create_events_table.py following exact same pattern as 003:
    - revision "004", down_revision "003"
    - Create events table with all columns
    - event_date Date not null
    - event_time Time nullable
    - metadata JSONB with server_default '{}'::jsonb
    - created_at/updated_at with server_default func.now()
    - FK to cases.id ondelete CASCADE
    - FK to users.id ondelete RESTRICT
    - Indexes: ix_events_case_id, ix_events_event_date
    - Downgrade drops indexes then table
  </action>
  <verify>
    - Python files parse without syntax errors: python -c "from src.models.event import Event; from src.schemas.event import EventCreate, EventUpdate, EventRead, EventListResponse"
  </verify>
  <done>Event model, schemas, and migration exist with correct column types and relationships</done>
</task>

<task type="auto">
  <name>Task 2: Events CRUD router</name>
  <files>
    server/src/routers/events.py
    server/src/main.py
  </files>
  <action>
    Create server/src/routers/events.py with router prefix "/cases/{case_id}/events" and tag "events":

    Helper: _verify_case_exists(case_id, db) that fetches the case or raises 404.

    Endpoints:
    1. POST "/" - Create event
       - Verify case exists
       - Validate event_type is one of: "finding", "action", "note"
       - Create Event with case_id and created_by_id from current_user
       - Return EventRead with 201 status

    2. GET "/" - List events for a case
       - Verify case exists
       - Query events where case_id matches
       - Order by event_date ASC, event_time ASC NULLS LAST, sort_order ASC
       - Return EventListResponse with items and total count
       - No pagination needed initially (events per case are typically <100)

    3. GET "/{event_id}" - Get single event
       - Verify case exists and event belongs to case
       - Return EventRead

    4. PATCH "/{event_id}" - Update event
       - Verify case exists and event belongs to case
       - Apply partial update using model_dump(exclude_unset=True)
       - For metadata field, replace entire dict (same JSONB pattern as cases)
       - Validate event_type if present
       - Return updated EventRead

    5. DELETE "/{event_id}" - Delete event
       - Verify case exists and event belongs to case
       - Delete and return 204

    Register router in server/src/main.py: import and include_router for events.

    Follow exact same code patterns as cases.py for query building, error handling, and response construction.
  </action>
  <verify>
    - Python files parse: python -c "from src.routers.events import router"
    - Main app imports: python -c "from src.main import app"
  </verify>
  <done>Events CRUD API is fully functional with 5 endpoints nested under cases</done>
</task>

</tasks>

<verification>
- All Python files parse without errors
- Event model has correct columns matching requirements (EVNT-04: date, time, file name, file count, file description, file type)
- Events are nested under cases in the URL path
- Migration creates events table with proper foreign keys and indexes
</verification>

<success_criteria>
- Event model with all required fields exists
- Alembic migration 004 creates the events table
- CRUD router provides POST/GET/PATCH/DELETE for events under /cases/{case_id}/events
- Router registered in main.py
</success_criteria>

<output>
After completion, create `.planning/phases/03-timeline-events/03-01-SUMMARY.md`
</output>
