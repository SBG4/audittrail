---
phase: 01-infrastructure-auth
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - server/src/database.py
  - server/src/models/__init__.py
  - server/src/models/user.py
  - server/src/schemas/__init__.py
  - server/src/schemas/auth.py
  - server/src/schemas/user.py
  - server/src/routers/__init__.py
  - server/src/routers/auth.py
  - server/src/deps.py
  - server/src/main.py
  - server/src/scripts/__init__.py
  - server/src/scripts/seed.py
  - server/alembic.ini
  - server/alembic/env.py
  - server/alembic/script.py.mako
  - server/alembic/versions/001_create_users_table.py
autonomous: true

must_haves:
  truths:
    - "POST /api/auth/login with valid credentials returns a JWT access token"
    - "POST /api/auth/login with invalid credentials returns 401"
    - "GET /api/auth/me with valid JWT returns the current user's info"
    - "GET /api/auth/me without JWT returns 401"
    - "Alembic migrations create the users table on container startup"
    - "Default admin user is seeded on first startup"
  artifacts:
    - path: "server/src/database.py"
      provides: "Async SQLAlchemy engine, session factory, Base model"
      contains: "create_async_engine"
    - path: "server/src/models/user.py"
      provides: "User SQLAlchemy model with UUID, username, hashed_password, full_name, is_active"
      contains: "class User"
    - path: "server/src/routers/auth.py"
      provides: "Auth endpoints: POST /auth/login, GET /auth/me"
      contains: "def login"
    - path: "server/src/deps.py"
      provides: "FastAPI dependencies: get_db, get_current_user"
      exports: ["get_db", "get_current_user"]
    - path: "server/src/scripts/seed.py"
      provides: "Default admin user seeder"
      contains: "admin"
    - path: "server/alembic/versions/001_create_users_table.py"
      provides: "Initial migration creating users table"
      contains: "create_table"
  key_links:
    - from: "server/src/routers/auth.py"
      to: "server/src/deps.py"
      via: "Depends(get_db) and Depends(get_current_user)"
      pattern: "Depends\\(get_db\\)"
    - from: "server/src/deps.py"
      to: "server/src/database.py"
      via: "async_session import for get_db"
      pattern: "from src.database import"
    - from: "server/src/deps.py"
      to: "server/src/models/user.py"
      via: "User model import for JWT user lookup"
      pattern: "from src.models.user import User"
    - from: "server/src/main.py"
      to: "server/src/routers/auth.py"
      via: "app.include_router"
      pattern: "include_router.*auth"
    - from: "server/src/scripts/seed.py"
      to: "server/src/database.py"
      via: "async_session for database access"
      pattern: "from src.database import"
---

<objective>
Implement the complete backend: database layer (SQLAlchemy async engine, User model, Alembic migrations, seed data) and JWT authentication endpoints (login, current user). After this plan, the API accepts login requests, returns JWTs, and validates them on protected endpoints.

Purpose: Provide the authentication backend that the React frontend (Plan 01-03) will consume. This is the data + auth backbone of Phase 1.

Output: Working auth API with database migrations, user seeding, and JWT token flow.
</objective>

<execution_context>
@/Users/shiro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shiro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-auth/01-RESEARCH.md
@.planning/phases/01-infrastructure-auth/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database layer, User model, and Alembic migrations</name>
  <files>
    server/src/database.py
    server/src/models/__init__.py
    server/src/models/user.py
    server/alembic.ini
    server/alembic/env.py
    server/alembic/script.py.mako
    server/alembic/versions/001_create_users_table.py
  </files>
  <action>
    1. Create `server/src/database.py` per research Pattern 2:
       - Import `create_async_engine`, `async_sessionmaker`, `AsyncSession` from sqlalchemy.ext.asyncio
       - Import `DeclarativeBase` from sqlalchemy.orm
       - Import settings from `src.config`
       - Create async engine: `create_async_engine(settings.DATABASE_URL, pool_size=5, max_overflow=5, echo=False)`
       - Create session factory: `async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False, autoflush=False)`
       - Create `Base(DeclarativeBase)` base class
       - Create `async def get_db()` generator yielding sessions (will also be in deps.py for FastAPI injection)

    2. Create `server/src/models/__init__.py` that imports User (so Alembic can discover models):
       ```python
       from src.models.user import User
       __all__ = ["User"]
       ```

    3. Create `server/src/models/user.py` per research code example:
       - `class User(Base)` with `__tablename__ = "users"`
       - Fields: `id` (UUID, primary_key, default uuid4), `username` (String(50), unique, not null, indexed), `hashed_password` (String(255), not null), `full_name` (String(100), not null), `is_active` (Boolean, default True)
       - Use `Mapped` and `mapped_column` (SQLAlchemy 2.0 pattern)

    4. Initialize Alembic with SYNC driver (per research Pitfall 3):
       - Run `cd server && alembic init alembic`
       - Edit `server/alembic.ini`: Set `sqlalchemy.url` to use env var via `%(DATABASE_URL_SYNC)s` or hardcode `postgresql+psycopg2://audittrail:audittrail@db:5432/audittrail` as default. The simplest approach: let env.py read from config.
       - Edit `server/alembic/env.py`:
         - Import `settings` from `src.config` and `Base` from `src.database`
         - Import `src.models` to register all models with Base.metadata
         - Set `target_metadata = Base.metadata`
         - In `run_migrations_online()`, use `settings.DATABASE_URL_SYNC` as the connection URL (sync psycopg2 driver, NOT asyncpg)
         - Override the sqlalchemy.url from alembic.ini with the settings value

    5. Create the initial migration for users table:
       - Run `cd server && alembic revision --autogenerate -m "create users table"` OR create manually as `server/alembic/versions/001_create_users_table.py`
       - The migration should create the `users` table with all columns matching the User model
       - If autogenerate doesn't work in the dev environment (no DB running), create the migration manually with `op.create_table(...)` and `op.drop_table(...)`
  </action>
  <verify>
    Run `cd server && uv run python -c "from src.database import Base, engine; from src.models import User; print(User.__tablename__)"` prints "users".
    Run `cd server && uv run python -c "from src.models.user import User; print([c.name for c in User.__table__.columns])"` shows id, username, hashed_password, full_name, is_active.
    Verify `server/alembic/versions/` contains the initial migration file.
    Verify `server/alembic/env.py` imports Base.metadata and uses sync database URL.
  </verify>
  <done>
    SQLAlchemy async engine configured, User model defined with UUID primary key and all required fields, Alembic initialized with sync driver, initial migration created for users table.
  </done>
</task>

<task type="auto">
  <name>Task 2: JWT auth endpoints, dependencies, seed script, and route registration</name>
  <files>
    server/src/schemas/__init__.py
    server/src/schemas/auth.py
    server/src/schemas/user.py
    server/src/routers/__init__.py
    server/src/routers/auth.py
    server/src/deps.py
    server/src/scripts/__init__.py
    server/src/scripts/seed.py
    server/src/main.py
  </files>
  <action>
    1. Create Pydantic schemas:

       `server/src/schemas/__init__.py` (empty).

       `server/src/schemas/auth.py`:
       - `Token(BaseModel)`: `access_token: str`, `token_type: str = "bearer"`
       - `TokenData(BaseModel)`: `username: str | None = None`

       `server/src/schemas/user.py`:
       - `UserRead(BaseModel)`: `id: uuid.UUID`, `username: str`, `full_name: str`, `is_active: bool` -- with `model_config = ConfigDict(from_attributes=True)`

    2. Create `server/src/deps.py` with FastAPI dependencies per research Pattern 3:
       - `get_db()`: Async generator yielding `AsyncSession` from `async_session`
       - `password_hash = PasswordHash.recommended()` from pwdlib
       - `oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/auth/login")` -- NOTE: tokenUrl must include /api prefix because it's the URL the client calls, and the client goes through Nginx which routes /api/* to FastAPI
       - `verify_password(plain_password, hashed_password) -> bool`
       - `get_password_hash(password) -> str`
       - `create_access_token(data: dict, expires_delta: timedelta | None) -> str` using `jwt.encode()` with `settings.SECRET_KEY` and `settings.ALGORITHM`
       - `get_current_user(token: str = Depends(oauth2_scheme), db: AsyncSession = Depends(get_db)) -> User`: Decode JWT, extract username from "sub" claim, query User by username, raise 401 if invalid

    3. Create `server/src/routers/__init__.py` (empty).

    4. Create `server/src/routers/auth.py`:
       - Router with `prefix="/auth"`, `tags=["auth"]`
       - `POST /login`: Accept `OAuth2PasswordRequestForm` (from fastapi.security), look up user by username, verify password, return `Token` with JWT. Return 401 with "Incorrect username or password" on failure.
       - `GET /me`: Requires `current_user: User = Depends(get_current_user)`, returns `UserRead` from the current user.

    5. Create `server/src/scripts/__init__.py` (empty).

    6. Create `server/src/scripts/seed.py` per research:
       - Async function that checks if "admin" user exists
       - If not, creates admin user with: username="admin", password hash of "changeme", full_name="Default Admin"
       - Uses `PasswordHash.recommended().hash("changeme")` for the password
       - Runs via `asyncio.run(seed())` when called as `python -m src.scripts.seed`

    7. Update `server/src/main.py`:
       - Import and include the auth router: `app.include_router(auth_router)`
       - Keep the existing `/health` endpoint
  </action>
  <verify>
    After `docker compose up -d` (or rebuilding the api service):
    1. `curl -s http://localhost/api/health` returns `{"status":"ok"}`
    2. `curl -s -X POST http://localhost/api/auth/login -d "username=admin&password=changeme"` returns `{"access_token":"...","token_type":"bearer"}`
    3. Extract the token and `curl -s -H "Authorization: Bearer <token>" http://localhost/api/auth/me` returns `{"id":"...","username":"admin","full_name":"Default Admin","is_active":true}`
    4. `curl -s -X POST http://localhost/api/auth/login -d "username=admin&password=wrong"` returns 401
    5. `curl -s -H "Authorization: Bearer invalid" http://localhost/api/auth/me` returns 401
  </verify>
  <done>
    JWT authentication fully working: login endpoint accepts credentials and returns JWT, /me endpoint validates JWT and returns user info, invalid credentials/tokens return 401, default admin user seeded on startup.
  </done>
</task>

</tasks>

<verification>
1. `docker compose up -d` -- api service runs migrations and seeds admin user on startup
2. `curl -X POST http://localhost/api/auth/login -d "username=admin&password=changeme"` returns 200 + JWT
3. `curl -H "Authorization: Bearer <jwt>" http://localhost/api/auth/me` returns 200 + user info
4. Invalid credentials return 401
5. Invalid/missing JWT returns 401
6. Database `users` table exists with admin row after first startup
</verification>

<success_criteria>
- Alembic migration creates users table on container startup
- Default admin user seeded with hashed password
- Login endpoint authenticates and returns JWT
- Protected endpoint validates JWT and returns user data
- Invalid auth attempts properly rejected with 401
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-auth/01-02-SUMMARY.md`
</output>
