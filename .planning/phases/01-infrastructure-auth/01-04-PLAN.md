---
phase: 01-infrastructure-auth
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - docker-compose.yml
  - nginx/Dockerfile
  - server/Dockerfile
autonomous: false

must_haves:
  truths:
    - "User can open http://localhost in a browser and see the login page"
    - "User can log in with username 'admin' and password 'changeme', and is redirected to the dashboard"
    - "User's session persists after refreshing the browser (JWT in localStorage)"
    - "User can click logout and is redirected to the login page"
    - "Application starts via docker compose up with no errors"
    - "Database data persists after docker compose down and docker compose up"
  artifacts:
    - path: "docker-compose.yml"
      provides: "Complete three-service stack"
      contains: "postgres_data"
  key_links:
    - from: "client/src/stores/authStore.ts"
      to: "/api/auth/login"
      via: "login() posts credentials to backend"
      pattern: "/api/auth/login"
    - from: "client/src/stores/authStore.ts"
      to: "/api/auth/me"
      via: "initialize() fetches user on page load"
      pattern: "/api/auth/me"
    - from: "client/src/components/AuthGuard.tsx"
      to: "client/src/stores/authStore.ts"
      via: "checks isAuthenticated for route protection"
      pattern: "isAuthenticated"
    - from: "nginx/nginx.conf"
      to: "api:8000"
      via: "proxies /api/ to FastAPI"
      pattern: "proxy_pass"
---

<objective>
Rebuild Docker images with the complete backend (Plan 01-02) and frontend (Plan 01-03) code, verify the full end-to-end authentication flow works in the containerized environment, test data persistence across restarts, and validate airgap compliance.

Purpose: This is the integration plan that proves Phase 1's success criteria are met. Backend and frontend were built in parallel (Wave 2) -- this plan wires them together in Docker and verifies the complete user journey.

Output: Fully working Phase 1 application with verified auth flow, persistence, and airgap compliance.
</objective>

<execution_context>
@/Users/shiro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shiro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-auth/01-RESEARCH.md
@.planning/phases/01-infrastructure-auth/01-01-SUMMARY.md
@.planning/phases/01-infrastructure-auth/01-02-SUMMARY.md
@.planning/phases/01-infrastructure-auth/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rebuild images, fix integration issues, verify API flow</name>
  <files>
    docker-compose.yml
    nginx/Dockerfile
    server/Dockerfile
  </files>
  <action>
    1. Rebuild all Docker images:
       ```bash
       docker compose build --no-cache
       ```

    2. Start the stack:
       ```bash
       docker compose up -d
       ```

    3. Wait for all services to be healthy:
       ```bash
       docker compose ps  # All services should show healthy/running
       ```

    4. Verify backend API through Nginx:
       ```bash
       # Health check
       curl -s http://localhost/api/health
       # Expected: {"status":"ok"}

       # Login
       curl -s -X POST http://localhost/api/auth/login -d "username=admin&password=changeme"
       # Expected: {"access_token":"...","token_type":"bearer"}

       # Use the token to hit /me
       TOKEN=$(curl -s -X POST http://localhost/api/auth/login -d "username=admin&password=changeme" | python3 -c "import sys,json; print(json.load(sys.stdin)['access_token'])")
       curl -s -H "Authorization: Bearer $TOKEN" http://localhost/api/auth/me
       # Expected: {"id":"...","username":"admin","full_name":"Default Admin","is_active":true}
       ```

    5. Fix any integration issues:
       - If Nginx returns 502 for /api/, check that the api service is running and the proxy_pass URL matches
       - If login fails with CORS, verify requests go through Nginx (same origin) not directly to port 8000
       - If migrations fail, check DATABASE_URL_SYNC env var is correctly set in docker-compose.yml
       - If the React build in Nginx Dockerfile fails, ensure the build context and COPY paths are correct

    6. Test data persistence:
       ```bash
       docker compose down
       docker compose up -d
       # Login should still work (admin user persists in named volume)
       curl -s -X POST http://localhost/api/auth/login -d "username=admin&password=changeme"
       ```

    7. Run airgap verification:
       ```bash
       bash scripts/verify-airgap.sh
       ```
  </action>
  <verify>
    `docker compose ps` shows all 3 services running/healthy.
    `curl http://localhost/api/health` returns 200 + `{"status":"ok"}`.
    Login returns 200 + JWT token.
    /me with valid JWT returns user data.
    After down/up cycle, login still works (data persisted).
    `scripts/verify-airgap.sh` passes.
  </verify>
  <done>
    Backend API fully operational through Nginx reverse proxy. Authentication endpoints working. Data persists across container restarts. Airgap compliance verified.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify full auth flow in browser</name>
  <files>
    docker-compose.yml
  </files>
  <action>
    CHECKPOINT: Human verification of the complete Phase 1 auth flow in a browser.

    What was built:
    Complete Phase 1 application: Docker Compose stack with FastAPI backend, PostgreSQL database, and Nginx serving the React SPA. JWT authentication with login, session persistence, and logout.

    Steps for the user to verify:
    1. Open http://localhost in your browser
    2. Verify you see the AuditTrail login page with username and password fields
    3. Try logging in with wrong credentials (e.g., username: "admin", password: "wrong")
       - Verify an error message appears (e.g., "Invalid credentials")
    4. Log in with correct credentials: username "admin", password "changeme"
       - Verify you are redirected to the dashboard
       - Verify you see "Welcome, Default Admin" (or similar greeting)
       - Verify the header shows "AuditTrail" and a logout button
    5. Refresh the browser (F5 or Cmd+R)
       - Verify you remain on the dashboard (session persists via JWT in localStorage)
    6. Click the "Logout" button
       - Verify you are redirected to the login page
    7. Try navigating directly to http://localhost/ without logging in
       - Verify you are redirected to the login page (AuthGuard working)

    Resume signal: Type "approved" to complete Phase 1, or describe any issues found.
  </action>
  <verify>User confirms all 7 verification steps pass in the browser.</verify>
  <done>Phase 1 auth flow verified by user: login, session persistence, logout, and route protection all work correctly in the browser.</done>
</task>

</tasks>

<verification>
Phase 1 Success Criteria (from ROADMAP.md):
1. [x] User can open the application in a browser and see a login page
2. [x] User can log in with username and password, and their session persists after refreshing the browser
3. [x] User can log out from any page and is redirected to the login screen
4. [x] Application starts via `docker compose up` with no internet access required after image build
5. [x] Database data persists after running `docker compose down` and `docker compose up` again
</verification>

<success_criteria>
- Full auth flow works in browser: login, session persistence on refresh, logout
- Docker Compose stack starts cleanly with docker compose up
- All Phase 1 requirements met: AUTH-01, AUTH-02, AUTH-03, INFR-01, INFR-02, INFR-03
- Human verification of browser-based auth flow approved
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-auth/01-04-SUMMARY.md`
</output>
