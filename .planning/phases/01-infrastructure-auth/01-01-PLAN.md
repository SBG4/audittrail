---
phase: 01-infrastructure-auth
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docker-compose.yml
  - docker-compose.override.yml
  - .env.example
  - .env
  - server/pyproject.toml
  - server/Dockerfile
  - server/src/__init__.py
  - server/src/main.py
  - server/src/config.py
  - server/scripts/entrypoint.sh
  - client/package.json
  - client/vite.config.ts
  - client/tsconfig.json
  - client/tsconfig.app.json
  - client/tsconfig.node.json
  - client/index.html
  - client/src/main.tsx
  - client/src/App.tsx
  - client/src/app.css
  - client/src/vite-env.d.ts
  - nginx/nginx.conf
  - nginx/Dockerfile
  - scripts/verify-airgap.sh
autonomous: true

must_haves:
  truths:
    - "docker compose build completes successfully for all three services (api, db, nginx)"
    - "docker compose up starts all three containers with healthy status"
    - "Nginx serves a placeholder page at http://localhost and proxies /api/ to FastAPI"
    - "FastAPI returns a health check response at /api/health"
    - "PostgreSQL named volume persists data across down/up cycles"
  artifacts:
    - path: "docker-compose.yml"
      provides: "Three-service Docker Compose stack with named volumes"
      contains: "postgres_data"
    - path: "server/Dockerfile"
      provides: "Multi-stage Python build with uv and WeasyPrint system deps"
      contains: "uv sync"
    - path: "server/src/main.py"
      provides: "FastAPI app entry point with /api/health endpoint"
      contains: "FastAPI"
    - path: "server/src/config.py"
      provides: "Pydantic BaseSettings loading env vars"
      contains: "BaseSettings"
    - path: "nginx/nginx.conf"
      provides: "Reverse proxy config for SPA + API"
      contains: "proxy_pass"
    - path: "nginx/Dockerfile"
      provides: "Multi-stage Nginx build with React SPA"
      contains: "pnpm build"
    - path: "client/package.json"
      provides: "React project with Vite, TypeScript, Tailwind"
      contains: "react"
    - path: "scripts/verify-airgap.sh"
      provides: "Post-build airgap smoke test"
      contains: "network none"
  key_links:
    - from: "docker-compose.yml"
      to: "server/Dockerfile"
      via: "build context ./server"
      pattern: "build.*context.*server"
    - from: "docker-compose.yml"
      to: "nginx/Dockerfile"
      via: "build context ./nginx"
      pattern: "build.*context.*nginx"
    - from: "nginx/nginx.conf"
      to: "api:8000"
      via: "proxy_pass directive"
      pattern: "proxy_pass.*api:8000"
    - from: "server/scripts/entrypoint.sh"
      to: "server/src/main.py"
      via: "uvicorn startup command"
      pattern: "uvicorn src.main:app"
---

<objective>
Scaffold the complete Docker Compose stack with three services (FastAPI API, PostgreSQL database, Nginx reverse proxy), all project configuration files, and minimal working applications that build and run together.

Purpose: Establish the foundational infrastructure that all subsequent plans build upon. After this plan, `docker compose up` brings up a working stack with a FastAPI health endpoint, an Nginx-served React placeholder, and a persistent PostgreSQL database.

Output: Working Docker Compose stack with all Dockerfiles, project configs, and a passing airgap verification script.
</objective>

<execution_context>
@/Users/shiro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shiro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-auth/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold server project with FastAPI, Docker, and config</name>
  <files>
    server/pyproject.toml
    server/uv.lock
    server/Dockerfile
    server/src/__init__.py
    server/src/main.py
    server/src/config.py
    server/scripts/entrypoint.sh
    .env.example
    .env
  </files>
  <action>
    Create the server/ directory as a Python project managed by uv:

    1. Run `uv init server` then `cd server && uv add fastapi "uvicorn[standard]" "sqlalchemy[asyncio]" asyncpg alembic pydantic pyjwt "pwdlib[argon2]" python-multipart psycopg2-binary && uv add --dev pytest pytest-asyncio httpx ruff`. Note: psycopg2-binary is for Alembic sync migrations (per research finding on Pitfall 3).

    2. Create `server/src/__init__.py` (empty).

    3. Create `server/src/config.py` with Pydantic BaseSettings:
       - `DATABASE_URL: str` (default: `postgresql+asyncpg://audittrail:audittrail@db:5432/audittrail`)
       - `DATABASE_URL_SYNC: str` (default: `postgresql+psycopg2://audittrail:audittrail@db:5432/audittrail`) -- for Alembic
       - `SECRET_KEY: str` (default: `change-me-in-production`)
       - `ALGORITHM: str = "HS256"`
       - `ACCESS_TOKEN_EXPIRE_MINUTES: int = 480`
       - Use `model_config = SettingsConfigDict(env_file=".env")` for local dev.
       - Export a `settings = Settings()` singleton.

    4. Create `server/src/main.py`:
       - Import FastAPI, create `app = FastAPI(title="AuditTrail", root_path="/api")`
       - Add a `GET /health` endpoint returning `{"status": "ok"}`
       - This is the minimal app -- auth routes added in Plan 01-02.
       - NOTE: Use `root_path="/api"` so FastAPI knows it is mounted under /api by Nginx. Routes in FastAPI are defined WITHOUT the /api prefix (e.g., `/health`, `/auth/login`), and Nginx strips the prefix when proxying.

    5. Create `server/Dockerfile` as multi-stage build per research:
       - Builder stage: `FROM python:3.12-slim`, copy uv from `ghcr.io/astral-sh/uv:latest`, `uv sync --locked --no-install-project --no-editable --no-dev`, then copy source and `uv sync --locked --no-editable --no-dev`.
       - Production stage: `FROM python:3.12-slim`, install WeasyPrint system deps proactively (`apt-get install -y --no-install-recommends libpango-1.0-0 libpangocairo-1.0-0 libgdk-pixbuf2.0-0 libcairo2 libffi-dev libjpeg62-turbo libopenjp2-7`), copy .venv, src, alembic, alembic.ini, scripts from builder. Set `PATH="/app/.venv/bin:$PATH"`. Entrypoint is `/app/scripts/entrypoint.sh`.

    6. Create `server/scripts/entrypoint.sh`:
       ```bash
       #!/bin/sh
       set -e
       echo "Running database migrations..."
       alembic upgrade head
       echo "Seeding default data..."
       python -m src.scripts.seed || echo "Seed script not found, skipping"
       echo "Starting application..."
       exec uvicorn src.main:app --host 0.0.0.0 --port 8000 --proxy-headers
       ```
       Make it executable (`chmod +x`).

    7. Create `.env.example` with all env vars documented:
       ```
       DB_USER=audittrail
       DB_PASSWORD=audittrail
       SECRET_KEY=change-me-in-production
       APP_PORT=80
       ```

    8. Create `.env` as a copy of `.env.example` for local development. Add `.env` to `.gitignore`.

    9. Create `.gitignore` at project root with entries for: `.env`, `__pycache__`, `*.pyc`, `.venv`, `node_modules`, `dist`, `.ruff_cache`, `.pytest_cache`.
  </action>
  <verify>
    Run `cd server && uv sync --locked` completes without error.
    Run `cd server && uv run python -c "from src.main import app; print(app.title)"` prints "AuditTrail".
    Run `cd server && uv run python -c "from src.config import settings; print(settings.ALGORITHM)"` prints "HS256".
    Verify `server/scripts/entrypoint.sh` is executable.
  </verify>
  <done>
    Server project initialized with all dependencies locked, FastAPI app importable, config loading from env vars, Dockerfile ready, entrypoint script executable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Scaffold client project with Vite, React, Tailwind, and Nginx</name>
  <files>
    client/package.json
    client/pnpm-lock.yaml
    client/vite.config.ts
    client/tsconfig.json
    client/tsconfig.app.json
    client/tsconfig.node.json
    client/index.html
    client/src/main.tsx
    client/src/App.tsx
    client/src/app.css
    client/src/vite-env.d.ts
    nginx/nginx.conf
    nginx/Dockerfile
  </files>
  <action>
    1. Scaffold the React project:
       ```bash
       cd /path/to/project
       pnpm create vite client --template react-ts
       cd client
       pnpm add react-router zustand
       pnpm add -D tailwindcss @tailwindcss/vite
       ```

    2. Configure Vite (`client/vite.config.ts`):
       - Import tailwindcss plugin from `@tailwindcss/vite`
       - Add tailwindcss() to plugins array
       - Keep react() plugin

    3. Set up Tailwind CSS v4 in `client/src/app.css`:
       - Add `@import "tailwindcss";` at the top of the file (Tailwind v4 uses CSS-first config, no tailwind.config.js needed)

    4. Create minimal `client/src/App.tsx`:
       ```tsx
       function App() {
         return (
           <div className="flex items-center justify-center min-h-screen bg-gray-50">
             <h1 className="text-2xl font-bold text-gray-900">AuditTrail</h1>
           </div>
         );
       }
       export default App;
       ```

    5. Update `client/src/main.tsx` to import `./app.css` (Vite template may already do this, but ensure Tailwind CSS file is imported).

    6. Create `nginx/nginx.conf`:
       ```nginx
       server {
           listen 80;
           server_name _;

           location / {
               root /usr/share/nginx/html;
               index index.html;
               try_files $uri $uri/ /index.html;
           }

           location /api/ {
               proxy_pass http://api:8000/api/;
               proxy_set_header Host $host;
               proxy_set_header X-Real-IP $remote_addr;
               proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
               proxy_set_header X-Forwarded-Proto $scheme;
           }
       }
       ```

    7. Create `nginx/Dockerfile` as multi-stage build:
       - Builder stage: `FROM node:22-slim`, enable corepack + pnpm, copy client source, `pnpm install --frozen-lockfile`, `pnpm build`.
       - Production stage: `FROM nginx:1.27-alpine`, copy dist from builder to `/usr/share/nginx/html`, copy `nginx.conf` to `/etc/nginx/conf.d/default.conf`.
       - IMPORTANT: The nginx Dockerfile build context is `./nginx`, but it needs access to client source. Solution: Set the build context to the project root in docker-compose.yml and use `dockerfile: nginx/Dockerfile`. The Dockerfile COPY commands reference `client/` relative to the project root.
  </action>
  <verify>
    Run `cd client && pnpm install && pnpm build` completes without errors and produces `client/dist/index.html`.
    Verify `nginx/nginx.conf` contains `proxy_pass http://api:8000` and `try_files`.
    Verify `nginx/Dockerfile` has multi-stage build with node builder and nginx production stages.
  </verify>
  <done>
    Client project builds successfully with Vite + React + TypeScript + Tailwind CSS v4. Nginx config proxies /api/ to FastAPI and serves SPA with fallback routing. Nginx Dockerfile builds React app and serves from nginx:alpine.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Docker Compose stack and verify end-to-end</name>
  <files>
    docker-compose.yml
    docker-compose.override.yml
    scripts/verify-airgap.sh
  </files>
  <action>
    1. Create `docker-compose.yml` with three services per research Pattern 1:

       **db service:**
       - `image: postgres:17-slim`
       - Environment: `POSTGRES_DB=audittrail`, `POSTGRES_USER=${DB_USER:-audittrail}`, `POSTGRES_PASSWORD=${DB_PASSWORD:-audittrail}`
       - Volume: `postgres_data:/var/lib/postgresql/data` (MUST be /data, not just /postgresql -- see Pitfall 1)
       - Healthcheck: `pg_isready -U ${DB_USER:-audittrail} -d audittrail` with interval 5s, timeout 5s, retries 5, start_period 10s
       - restart: unless-stopped

       **api service:**
       - Build context: `./server`, dockerfile: `Dockerfile`
       - Environment: `DATABASE_URL=postgresql+asyncpg://${DB_USER:-audittrail}:${DB_PASSWORD:-audittrail}@db:5432/audittrail`, `DATABASE_URL_SYNC=postgresql+psycopg2://${DB_USER:-audittrail}:${DB_PASSWORD:-audittrail}@db:5432/audittrail`, `SECRET_KEY=${SECRET_KEY:-change-me-in-production}`, `ALGORITHM=HS256`, `ACCESS_TOKEN_EXPIRE_MINUTES=480`
       - depends_on: db with `condition: service_healthy`
       - restart: unless-stopped

       **nginx service:**
       - Build context: `.` (project root), dockerfile: `nginx/Dockerfile`
       - Ports: `${APP_PORT:-80}:80`
       - depends_on: api
       - restart: unless-stopped

       **Named volume:** `postgres_data`

    2. Create `docker-compose.override.yml` for development:
       - api service: expose port 8000:8000 for direct API access during dev
       - Add environment `PYTHONDONTWRITEBYTECODE=1`

    3. Create `scripts/verify-airgap.sh` per research:
       ```bash
       #!/bin/bash
       set -e
       echo "=== Airgap Verification ==="
       echo "Testing API container without network..."
       docker run --rm --network none $(docker compose images api -q) python -c "from src.main import app; print('FastAPI app imports successfully without network')"
       echo "Testing Nginx container without network..."
       docker run --rm --network none $(docker compose images nginx -q) nginx -t
       echo "=== All airgap checks passed ==="
       ```
       Make it executable.

    4. Run `docker compose build` to verify all images build successfully.
    5. Run `docker compose up -d` and verify all three services start.
    6. Test: `curl http://localhost/api/health` returns `{"status":"ok"}`.
    7. Test: `curl http://localhost` returns the React SPA HTML.
    8. Test persistence: `docker compose down && docker compose up -d`, verify db container starts without data loss (no Postgres init messages about creating database if volume persists).
    9. Run `docker compose down` to clean up.
  </action>
  <verify>
    `docker compose build` completes with exit code 0.
    `docker compose up -d` shows all three services healthy/running.
    `curl -s http://localhost/api/health` returns `{"status":"ok"}`.
    `curl -s http://localhost` contains "AuditTrail" (from React app).
    `docker compose down` then `docker compose up -d` -- db starts without re-initializing.
    `scripts/verify-airgap.sh` passes (after images are built).
  </verify>
  <done>
    Three-service Docker Compose stack builds and runs. Nginx serves React SPA at / and proxies /api/ to FastAPI. PostgreSQL data persists across container restarts via named volume. Airgap verification script confirms no outbound network needed.
  </done>
</task>

</tasks>

<verification>
1. `docker compose build` succeeds for all three images
2. `docker compose up -d` starts api, db, nginx -- all show as healthy/running
3. `curl http://localhost/api/health` returns 200 with `{"status":"ok"}`
4. `curl http://localhost` returns React SPA HTML containing "AuditTrail"
5. `docker compose down && docker compose up -d` -- PostgreSQL data volume persists
6. `bash scripts/verify-airgap.sh` passes
</verification>

<success_criteria>
- All three Docker images build successfully
- docker compose up starts the full stack with no errors
- FastAPI health endpoint accessible through Nginx reverse proxy
- React SPA served by Nginx with client-side routing support
- PostgreSQL data survives container restart cycle
- No internet access needed after image build (airgap verified)
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-auth/01-01-SUMMARY.md`
</output>
